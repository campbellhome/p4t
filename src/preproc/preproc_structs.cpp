#define _HAS_EXCEPTIONS 0
#define _ITERATOR_DEBUG_LEVEL 0

#include "file_utils.h"
#include "preproc.h"
#include "sdict.h"
#include "va.h"

static bool EndsWith(const std::string &str, const char *substr)
{
	bool ret = false;
	size_t substrLen = strlen(substr);
	size_t strLen = str.length();
	if(strLen > substrLen) {
		const char *end = str.c_str() + (strLen - substrLen);
		if(!strcmp(end, substr)) {
			ret = true;
		}
	}
	return ret;
}

static const char *GetMemberType(const std::string &typeStr)
{
	size_t len = typeStr.length();
	if(typeStr == "sb_t") {
		return "sb";
	} else if(typeStr == "sdict_t") {
		return "sdict";
	} else if(EndsWith(typeStr, "_t*")) {
		return va("%.*s", typeStr.length() - 3, typeStr.c_str());
	} else if(EndsWith(typeStr, "_t")) {
		return va("%.*s", typeStr.length() - 2, typeStr.c_str());
	} else if(EndsWith(typeStr, "*")) {
		return va("%.*s", typeStr.length() - 1, typeStr.c_str());
	} else {
		return typeStr.c_str();
	}
}

static void GenerateResetHeader(sb_t *srcDir)
{
	sb_t data;
	sb_init(&data);
	sb_t *s = &data;

	sb_append(s, "// Copyright (c) 2012-2019 Matt Campbell\n");
	sb_append(s, "// MIT license (see License.txt)\n");
	sb_append(s, "\n");
	sb_append(s, "// AUTOGENERATED FILE - DO NOT EDIT\n");
	sb_append(s, "\n");
	sb_append(s, "// clang-format off\n");
	sb_append(s, "\n");
	sb_append(s, "#pragma once\n");
	sb_append(s, "\n");
	sb_append(s, "#if defined(__cplusplus)\n");
	sb_append(s, "extern \"C\" {\n");
	sb_append(s, "#endif\n");
	sb_append(s, "\n");
	for(const struct_s &o : g_structs) {
		if(o.typedefBaseName.empty()) {
			sb_va(s, "struct %s;\n", o.name.c_str());
		} else {
			sb_va(s, "typedef struct %s %s;\n", o.typedefBaseName.c_str(), o.name.c_str());
		}
	}
	sb_append(s, "\n");
	for(const struct_s &o : g_structs) {
		if(o.fromLoc) {
			sb_va(s, "void %s_reset_from_loc(const char *file, int line, %s *val);\n", GetMemberType(o.name), o.name.c_str());
		} else {
			sb_va(s, "void %s_reset(%s *val);\n", GetMemberType(o.name), o.name.c_str());
		}
	}
	sb_append(s, "\n");
	for(const struct_s &o : g_structs) {
		if(o.fromLoc) {
			sb_va(s, "%s %s_clone_from_loc(const char *file, int line, %s *src);\n", o.name.c_str(), GetMemberType(o.name), o.name.c_str());
		} else {
			sb_va(s, "%s %s_clone(%s *src);\n", o.name.c_str(), GetMemberType(o.name), o.name.c_str());
		}
	}
	sb_append(s, "\n");
	sb_append(s, "#if defined(__cplusplus)\n");
	sb_append(s, "} // extern \"C\"\n");
	sb_append(s, "#endif\n");

	sb_t path;
	sb_init(&path);
	sb_va(&path, "%s\\structs_generated.h", sb_get(srcDir));
	fileData_writeIfChanged(sb_get(&path), NULL, { data.data, sb_len(s) });
	sb_reset(&path);
	sb_reset(&data);
}

enum memberJsonType_e {
	kMemberJsonObject,
	kMemberJsonBoolean,
	kMemberJsonNumber,
	kMemberJsonEnum,
};

static memberJsonType_e ClassifyMemberJson(const struct_member_s &m)
{
	if(m.typeStr == "bool" || m.typeStr == "b32" || m.typeStr == "b8") {
		return kMemberJsonBoolean;
	}
	for(const struct_s &s : g_structs) {
		if(s.name == m.typeStr) {
			return kMemberJsonObject;
		}
	}
	for(const enum_s &e : g_enums) {
		if(e.name == m.typeStr) {
			return kMemberJsonEnum;
		}
	}
	return kMemberJsonNumber;
}

static void GenerateResetSource(sb_t *srcDir)
{
	sb_t data;
	sb_init(&data);
	sb_t *s = &data;

	sb_append(s, "// Copyright (c) 2012-2019 Matt Campbell\n");
	sb_append(s, "// MIT license (see License.txt)\n");
	sb_append(s, "\n");
	sb_append(s, "// AUTOGENERATED FILE - DO NOT EDIT\n");
	sb_append(s, "\n");
	sb_append(s, "// clang-format off\n");
	sb_append(s, "\n");
	sb_append(s, "#include \"structs_generated.h\"\n");
	sb_append(s, "#include \"bb_array.h\"\n");
	sb_append(s, "#include \"va.h\"\n");
	sb_append(s, "\n");
	for(const std::string &str : g_paths) {
		sb_va(s, "#include \"%s\"\n", str.c_str());
	}
	sb_append(s, "\n");
	for(const struct_s &o : g_structs) {
		if(o.headerOnly)
			continue;
		const struct_member_s *m_count = nullptr;
		const struct_member_s *m_allocated = nullptr;
		const struct_member_s *m_data = nullptr;
		for(const struct_member_s &m : o.members) {
			if(m.name == "count") {
				m_count = &m;
			} else if(m.name == "allocated") {
				m_allocated = &m;
			} else if(m.name == "data") {
				m_data = &m;
			}
		}
		sb_append(s, "\n");
		sb_va(s, "void %s_reset(%s *val)\n", GetMemberType(o.name), o.name.c_str());
		sb_append(s, "{\n");
		sb_append(s, "\tif(val) {\n");
		if(o.members.size() == 3 && m_count && m_allocated && m_data) {
			sb_va(s, "\t\tfor(u32 i = 0; i < val->count; ++i) {\n");
			sb_va(s, "\t\t\t%s_reset(val->data + i);\n", GetMemberType(m_data->typeStr));
			sb_append(s, "\t\t}\n");
			sb_va(s, "\t\tbba_free(*val);\n", m_data->name.c_str());
		} else {
			for(const struct_member_s &m : o.members) {
				if(ClassifyMemberJson(m) != kMemberJsonObject) {
					continue;
				}
				if(m.arr.empty()) {
					sb_va(s, "\t\t%s_reset(&val->%s);\n", GetMemberType(m.typeStr), m.name.c_str());
				} else {
					sb_va(s, "\t\tfor(u32 i = 0; i < BB_ARRAYSIZE(val->%s); ++i) {\n", m.name.c_str());
					sb_va(s, "\t\t\t%s_reset(val->%s + i);\n", GetMemberType(m.typeStr), m.name.c_str());
					sb_append(s, "\t\t}\n");
				}
			}
		}
		sb_append(s, "\t}\n");
		sb_append(s, "}\n");
		sb_va(s, "%s %s_clone(%s *src)\n", o.name.c_str(), GetMemberType(o.name), o.name.c_str());
		sb_append(s, "{\n");
		sb_va(s, "\t%s dst = { 0 };\n", o.name.c_str());
		sb_append(s, "\tif(src) {\n");
		if(o.members.size() == 3 && m_count && m_allocated && m_data) {
			sb_va(s, "\t\tfor(u32 i = 0; i < src->count; ++i) {\n");
			sb_va(s, "\t\t\tif(bba_add_noclear(dst, 1)) {\n");
			sb_va(s, "\t\t\t\tbba_last(dst) = %s_clone(src->data + i);\n", GetMemberType(m_data->typeStr));
			sb_va(s, "\t\t\t}\n");
			sb_va(s, "\t\t}\n");
		} else {
			for(const struct_member_s &m : o.members) {
				if(m.arr.empty()) {
					if(ClassifyMemberJson(m) == kMemberJsonObject) {
						sb_va(s, "\t\tdst.%s = %s_clone(&src->%s);\n", m.name.c_str(), GetMemberType(m.typeStr), m.name.c_str());
					} else {
						sb_va(s, "\t\tdst.%s = src->%s;\n", m.name.c_str(), m.name.c_str());
					}
				} else {
					sb_va(s, "\t\tfor(u32 i = 0; i < BB_ARRAYSIZE(src->%s); ++i) {\n", m.name.c_str());
					if(ClassifyMemberJson(m) == kMemberJsonObject) {
						sb_va(s, "\t\t\tdst.%s[i] = %s_clone(&src->%s[i]);\n", m.name.c_str(), GetMemberType(m.typeStr), m.name.c_str());
					} else {
						sb_va(s, "\t\t\tdst.%s[i] = src->%s[i];\n", m.name.c_str(), m.name.c_str());
					}
					sb_append(s, "\t\t}\n");
				}
			}
		}
		sb_append(s, "\t}\n");
		sb_append(s, "\treturn dst;\n");
		sb_append(s, "}\n");
	}
	sb_t path;
	sb_init(&path);
	sb_va(&path, "%s\\structs_generated.c", sb_get(srcDir));
	fileData_writeIfChanged(sb_get(&path), NULL, { data.data, sb_len(s) });
	sb_reset(&path);
	sb_reset(&data);
}

void GenerateReset(sb_t *srcDir)
{
	GenerateResetHeader(srcDir);
	GenerateResetSource(srcDir);
}
